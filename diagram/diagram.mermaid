classDiagram
    %% Abstract Classes and Interfaces
    class Serializable {
        <<abstract>>
        +toDict() Dict~str, Any~*
        +fromDict(data)$ Serializable*
    }

    %% Enums
    class LogEntryType {
        <<enumeration>>
        START
        COMMIT
        ABORT
        UPDATE
        COMPENSATION
        CHECKPOINT
    }

    class TransactionState {
        <<enumeration>>
        ACTIVE
        PARTIALLY_COMMITTED
        COMMITTED
        ABORTED
        FAILED
    }

    %% Model Classes
    class ExecutionResult {
        -int _transactionId
        -datetime _timestamp
        -str _message
        -Union~Rows, int~ _data
        -str _query
        +getTransactionId() int
        +getTimestamp() datetime
        +getMessage() str
        +getData() Union~Rows, int~
        +getQuery() str
        +toDict() Dict~str, Any~
        +fromDict(data)$ ExecutionResult
    }

    class Rows {
        -List~Dict~ _data
        -int _rowsCount
        +getData() List~Dict~
        +getRowsCount() int
        +addRow(row) None
        +clear() None
    }

    class LogEntry {
        -int _logId
        -int _transactionId
        -datetime _timestamp
        -LogEntryType _entryType
        -Optional~str~ _dataItem
        -Optional~Any~ _oldValue
        -Optional~Any~ _newValue
        +getLogId() int
        +getTransactionId() int
        +getTimestamp() datetime
        +getEntryType() LogEntryType
        +getDataItem() Optional~str~
        +getOldValue() Optional~Any~
        +getNewValue() Optional~Any~
        +toDict() Dict~str, Any~
        +fromDict(data)$ LogEntry
        +performUndo() Any
        +performRedo() Any
        +toString() str
    }

    class Checkpoint {
        -int _checkpointId
        -datetime _timestamp
        -List~int~ _activeTransactions
        -int _lastLogId
        +getCheckpointId() int
        +getTimestamp() datetime
        +getActiveTransactions() List~int~
        +getLastLogId() int
        +hasActiveTransactions() bool
        +toDict() Dict~str, Any~
        +fromDict(data)$ Checkpoint
        +toString() str
    }

    class RecoveryCriteria {
        -Optional~datetime~ _timestamp
        -Optional~int~ _transactionId
        +getTimestamp() Optional~datetime~
        +getTransactionId() Optional~int~
        +matchesEntry(entryTimestamp, entryTransactionId) bool
        +isValid() bool
    }

    %% Helper Classes - Buffer
    class Buffer~T~ {
        -int _maxSize
        -Dict~str, BufferEntry~ _bufferPool
        -List~str~ _accessOrder
        +get(key) Optional~T~
        +put(key, data, isDirty) None
        +remove(key) None
        +isFull() bool
        +isNearlyFull(threshold) bool
        +getDirtyEntries() List~BufferEntry~
        +flushDirtyEntries() List~BufferEntry~
        +evictEntry() Optional~str~
        +clear() None
        +getSize() int
        +getMaxSize() int
        +pinEntry(key) bool
        +unpinEntry(key) bool
    }

    class BufferEntry~T~ {
        -str _key
        -T _data
        -bool _isDirty
        -datetime _lastAccessed
        -int _pinCount
        +getKey() str
        +getData() T
        +isDirty() bool
        +getLastAccessed() datetime
        +getPinCount() int
        +markDirty() None
        +markClean() None
        +pin() None
        +unpin() None
        +updateAccessTime() None
    }

    %% Helper Classes - Transaction
    class Transaction {
        -int _transactionId
        -TransactionState _state
        -datetime _startTimestamp
        -datetime _lastAccessTimestamp
        +getTransactionId() int
        +getState() TransactionState
        +setState(state) None
        +getStartTimestamp() datetime
        +getLastAccessTimestamp() datetime
        +updateLastAccessTimestamp(timestamp) None
        +isActive() bool
        +isCommitted() bool
        +isAborted() bool
        +canBeAborted() bool
    }

    class TransactionManager {
        <<singleton>>
        -Dict~int, Transaction~ _transactions
        -RLock _transactionLock
        -bool initialized
        +beginTransaction(transactionId) Transaction
        +getTransaction(transactionId) Optional~Transaction~
        +hasTransaction(transactionId) bool
        +commitTransaction(transactionId) bool
        +abortTransaction(transactionId) bool
        +getActiveTransactions() List~Transaction~
        +getActiveTransactionIds() List~int~
        +removeTransaction(transactionId) bool
        +clearCompletedTransactions() int
        +getTransactionCount() int
        +getActiveTransactionCount() int
        +getAllTransactions() Dict~int, Transaction~
        +getStatistics() Dict~str, int~
        +clear() None
    }

    %% Helper Classes - WAL and Recovery
    class WriteAheadLog {
        <<singleton>>
        -LogSerializer _logSerializer
        -int _currentLogId
        -int _currentCheckpointId
        -List~LogEntry~ _logBuffer
        -bool initialized
        -_loadCurrentState() None
        +appendLog(entry) None
        +appendLogFromExecution(executionResult) LogEntry
        +getNextLogId() int
        +getLogsForTransaction(transactionId) List~LogEntry~
        +getLogsSinceCheckpoint(checkpointId) List~LogEntry~
        +getLatestCheckpoint() Optional~Checkpoint~
        +createCheckpoint(activeTransactions) Checkpoint
        +getAllLogsBackward(fromLogId) List~LogEntry~
        +flushBuffer() None
        +needsFlush(bufferSizeThreshold) bool
        +truncateBeforeCheckpoint(checkpointId) None
        +verifyLogIntegrity() bool
        +getLogStatistics() dict
    }

    class LogSerializer {
        -Path _logFilePath
        -_ensureLogDirectory() None
        -_serializeDatetime(dt) str
        -_deserializeDatetime(dtStr) datetime
        +writeLogEntry(entryDict) None
        +writeLogEntries(entries) None
        +readAllLogs() List~Dict~
        +readLogsSince(logId) List~Dict~
        +readLogsBetween(startId, endId) List~Dict~
        +clearLogs() None
        +truncateLogsBefore(logId) None
        +backupLogs(backupPath) None
        +restoreLogs(backupPath) None
        +getLogFileSize() int
        +isLogFileLarge(thresholdMb) bool
    }

    class RecoveryExecutor {
        +executeUndo(logEntry) None
        +executeRedo(logEntry) None
        +performTransactionRollback(logs) None
        +matchesCriteria(logEntry, criteria) bool
    }

    %% Main Class
    class FailureRecoveryManager {
        <<singleton>>
        -WriteAheadLog _writeAheadLog
        -Buffer~Any~ _buffer
        -TransactionManager _transactionManager
        -RecoveryExecutor _recoveryExecutor
        -int _checkpointInterval
        -datetime _lastCheckpointTime
        -bool initialized
        +writeLog(info) None
        +saveCheckpoint() None
        +recover(criteria) None
        +recoverFromSystemFailure() None
        -_shouldCheckpoint() bool
        -_analysisPhase() tuple
        -_redoPhase(checkpoint) None
        -_undoPhase(activeTransactions) None
    }

    %% Relationships - Inheritance
    Serializable <|-- ExecutionResult
    Serializable <|-- LogEntry
    Serializable <|-- Checkpoint

    %% Relationships - Composition
    ExecutionResult *-- Rows
    LogEntry --> LogEntryType
    Transaction --> TransactionState
    Buffer *-- BufferEntry
    TransactionManager *-- Transaction
    WriteAheadLog *-- LogSerializer
    WriteAheadLog --> LogEntry
    WriteAheadLog --> Checkpoint
    WriteAheadLog --> ExecutionResult

    %% Relationships - Main Manager
    FailureRecoveryManager *-- WriteAheadLog
    FailureRecoveryManager *-- Buffer
    FailureRecoveryManager *-- TransactionManager
    FailureRecoveryManager *-- RecoveryExecutor
    FailureRecoveryManager --> ExecutionResult
    FailureRecoveryManager --> RecoveryCriteria

    %% Relationships - Recovery
    RecoveryExecutor --> LogEntry
    RecoveryExecutor --> RecoveryCriteria

    %% Helper Functions and Decorators
    class singleton {
        <<decorator>>
        +get_instance() T
    }

    class getFailureRecoveryManager {
        <<function>>
        +getFailureRecoveryManager() FailureRecoveryManager
    }

    singleton .. FailureRecoveryManager : applies
    singleton .. WriteAheadLog : applies
    singleton .. TransactionManager : applies
    getFailureRecoveryManager ..> FailureRecoveryManager : returns
